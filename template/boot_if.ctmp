// Copyright (c) 2023 Ziga Miklosic
// All Rights Reserved
// This software is under MIT licence (https://opensource.org/licenses/MIT)
////////////////////////////////////////////////////////////////////////////////
/**
*@file      boot_if.c
*@brief     Bootloader Interface
*@author    Ziga Miklosic
*@email     ziga.miklosic@gmail.com
*@date      10.08.2023
*@version   V0.1.0
*/
////////////////////////////////////////////////////////////////////////////////
/*!
* @addtogroup Bootloader Interface
* @{ <!-- BEGIN GROUP -->
*
*
*   @note   Change code only between "USER_CODE_BEGIN" and
*           "USER_CODE_END" section!
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "boot_if.h"

// USER INCLUDE BEGIN...

// HAL
#include "stm32g4xx_hal.h"

// Drivers
#include "drivers/peripheral/gpio/gpio/src/gpio.h"
#include "drivers/peripheral/uart/uart/src/uart.h"
#include "drivers/peripheral/flash/flash/src/flash.h"

// Middleware
#include "middleware/cli/cli/src/cli.h"

// USER INCLUDE END...

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Function prototypes
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*@addtogroup BOOT_IF_API
* @{ <!-- BEGIN GROUP -->
*
* 	Following function are part of Bootloader Interface API.
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*       Initialize Bootloader communication port
*
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_init(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eUART_OK != uart_init( eUART_BOOT ))
    {
        status = eBOOT_ERROR;
    }

    if ( eFLASH_OK != flash_init())
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Transmit data over Bootloader communication port
*
* @note In case of transmit error function shall return "eBOOT_ERROR" code!
*
* @param[in]    p_data  - Data to transmit
* @param[in]    size    - Size of data to transmit in bytes
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_transmit(const uint8_t * const p_data, const uint16_t size)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eUART_OK != uart_transmit( eUART_BOOT, p_data, size ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Receive data over Bootloader communication port
*
* @note In case of reception error or RX FIFO empty function shall return "eBOOT_ERROR" code!
*
* @param[in]    p_data  - Data to transmit
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_receive(uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eUART_OK != uart_receive( eUART_BOOT, p_data ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Clear Bootloader interface reception FIFO
*
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_clear_rx_buf(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eUART_OK != uart_clear_rx_buf( eUART_BOOT ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Write data to internal MCU flash
*
*   @note In case of write error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @param[in]    p_data  - Data to write
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_write(const uint32_t addr, const uint32_t size, const uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_write( addr, size, p_data ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Read data from internal MCU flash
*
*   @note In case of read error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @param[out]    p_data  - Data to write
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_read(const uint32_t addr, const uint32_t size, uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_read( addr, size, p_data ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Erase data in internal MCU flash
*
*   @note In case of write error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_erase(const uint32_t addr, const uint32_t size)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_erase( addr, size ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       De-initialize all used periphery
*
* @return       status - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_deinit(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

	// De-init gpio
	gpio_deinit();

	// Cli de-init
	cli_deinit();

	// De-init clocks
	HAL_RCC_DeInit();

	// De-init HAL
	HAL_DeInit();

	// Disable systick
	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////
