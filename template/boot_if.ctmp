// Copyright (c) 2023 Ziga Miklosic
// All Rights Reserved
// This software is under MIT licence (https://opensource.org/licenses/MIT)
////////////////////////////////////////////////////////////////////////////////
/**
*@file      boot_if.c
*@brief     Bootloader Interface
*@author    Ziga Miklosic
*@email     ziga.miklosic@gmail.com
*@date      10.08.2023
*@version   V0.1.0
*/
////////////////////////////////////////////////////////////////////////////////
/*!
* @addtogroup Bootloader Interface
* @{ <!-- BEGIN GROUP -->
*
*
*   @note   Change code only between "USER_CODE_BEGIN" and
*           "USER_CODE_END" section!
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "boot_if.h"

// USER INCLUDE BEGIN...

#include <string.h>

// HAL
#include "stm32g4xx_hal.h"

// Drivers
#include "drivers/peripheral/gpio/gpio/src/gpio.h"
#include "drivers/peripheral/uart/uart/src/uart.h"
#include "drivers/peripheral/flash/flash/src/flash.h"
#include "drivers/peripheral/can/can/src/can.h"

// Middleware
#include "middleware/cli/cli/src/cli.h"
#include "middleware/ring_buffer/src/ring_buffer.h"
#include "cmox_crypto.h"

// USER INCLUDE END...

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

/**
 *  Enable/Disable bootloader interface via CAN
 */
#define BOOT_IF_CAN_COM_EN                  ( 1 )

#if ( 1 == BOOT_IF_CAN_COM_EN )

    /**
     *  Reception buffer size in bytes
     */
    #define BOOT_IF_RX_BUF_SIZE             ( 512 )

    /**
     *  CAN Tx message ID
     *
     *  @note   According to "VendingMachine_CANMatrix.xlsx" specifications.
     */
    #define BOOT_IF_CAN_MSG_TX_ID           ( 0x400 )

    /**
     *  CAN Rx message ID
     *
     *  @note   According to "VendingMachine_CANMatrix.xlsx" specifications.
     */
    #define BOOT_IF_CAN_MSG_RX_ID           ( 0x401 )

#endif // ( 1 == BOOT_IF_CAN_COM_EN )

/**
 *      Enable/Disable cryption
 *
 *  @note   In debug mode, CMOX (encryption lib) is to big to be fit into boot flash!
 */
#define BOOT_IF_CRYPTION_EN                 ( 1 )


// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

#if ( 1 == BOOT_IF_CAN_COM_EN )

    /**
     *  CAN reception buffer by byte
     */
    static p_ring_buffer_t gp_rx_buf = NULL;

    /**
     *  FIFO buffer attributes
     */
    static const ring_buffer_attr_t g_buf_attr =
    {
       .item_size   = sizeof( uint8_t ),    // Byte size
       .override    = false,                // Do not lost data
       .p_mem       = NULL,                 // Dynamically allocate
    };

#endif

/**
 *  AES CTR context handle
 */
static cmox_ctr_handle_t g_ctr_ctx = {0};

/**
 *  AES cipher context handle
 */
static cmox_cipher_handle_t * gp_cipher_ctx = NULL;

/**
 *  AES CTR Encryption Key
 */
static const uint8_t gu8_key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };

/**
 *  AES CTR Initial Vector (IV) Key
 */
static const uint8_t gu8_iv[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Function prototypes
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

static boot_status_t bool_if_crypto_init(void);

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////

// USER CODE BEGIN...

////////////////////////////////////////////////////////////////////////////////
/**
*       Initialize cryptographic library
*
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
static boot_status_t bool_if_crypto_init(void)
{
    boot_status_t status = eBOOT_OK;

    // Initialize cryptographic library
    if ( CMOX_INIT_SUCCESS != cmox_initialize( NULL ))
    {
        status = eBOOT_ERROR;
    }

    // Construct a cipher context
    gp_cipher_ctx = cmox_ctr_construct( &g_ctr_ctx, CMOX_AESFAST_CTR_DEC );

    // Check for construction creation
    if ( NULL == gp_cipher_ctx )
    {
        status = eBOOT_ERROR;
    }

    // Initialize the cipher context
    if ( CMOX_CIPHER_SUCCESS != cmox_cipher_init( gp_cipher_ctx ))
    {
        status = eBOOT_ERROR;
    }

    // Setup decryption key
    if ( CMOX_CIPHER_SUCCESS != cmox_cipher_setKey( gp_cipher_ctx, gu8_key, sizeof( gu8_key )))
    {
        status = eBOOT_ERROR;
    }

    // Setup Initilization Vector (IV)
    if ( CMOX_CIPHER_SUCCESS != cmox_cipher_setIV( gp_cipher_ctx, gu8_iv, sizeof( gu8_iv )))
    {
        status = eBOOT_ERROR;
    }

    return status;
}

// USER CODE END...

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*@addtogroup BOOT_IF_API
* @{ <!-- BEGIN GROUP -->
*
* 	Following function are part of Bootloader Interface API.
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*       Initialize Bootloader communication port
*
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_init(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    #if ( 0 == BOOT_IF_CAN_COM_EN )
        #ifdef DEBUG
            if ( eUART_OK != uart_init( eUART_BOOT ))
            {
                status = eBOOT_ERROR;
            }
        #else
            if ( eUART_OK != uart_init( eUART_DBG ))
            {
                status = eBOOT_ERROR;
            }
        #endif
    #else

        if ( eCAN_OK != can_init( eCAN_SYSTEM ))
        {
            status = eBOOT_ERROR;
        }

        if ( eRING_BUFFER_OK != ring_buffer_init( &gp_rx_buf, BOOT_IF_RX_BUF_SIZE, &g_buf_attr ))
        {
            status = eBOOT_ERROR;
        }

    #endif // ( 0 == BOOT_IF_CAN_COM_EN )

    // Initialize cryptographic lib
    status |= bool_if_crypto_init();

    // Init flash driver
    if ( eFLASH_OK != flash_init())
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       De-initialize all used periphery
*
* @return       status - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_deinit(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    #if ( 1 == BOOT_IF_CRYPTION_EN)

        // De-Initialize cryptographic library
        if ( CMOX_INIT_SUCCESS != cmox_finalize( NULL ))
        {
            status = eBOOT_ERROR;
        }

    #endif

    // De-init gpio
    gpio_deinit();

    // De-init CAN
    #if ( 1 == BOOT_IF_CAN_COM_EN )
        can_deinit( eCAN_SYSTEM );
    #endif

    // Cli de-init
    cli_deinit();

    // De-init clocks
    HAL_RCC_DeInit();

    // De-init HAL
    HAL_DeInit();

    // Disable systick
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Transmit data over Bootloader communication port
*
* @note In case of transmit error function shall return "eBOOT_ERROR" code!
*
* @param[in]    p_data  - Data to transmit
* @param[in]    size    - Size of data to transmit in bytes
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_transmit(const uint8_t * const p_data, const uint16_t size)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    #if ( 0 == BOOT_IF_CAN_COM_EN )
        #ifdef DEBUG
            if ( eUART_OK != uart_transmit( eUART_BOOT, p_data, size ))
            {
                status = eBOOT_ERROR;
            }
        #else
            if ( eUART_OK != uart_transmit( eUART_DBG, p_data, size ))
            {
                status = eBOOT_ERROR;
            }
        #endif
    #else

        // Create CAN message
        can_msg_t msg =
        {
             .id    = BOOT_IF_CAN_MSG_TX_ID,
             .fd    = true,
             .dlc   = can_dlc_raw_to_real( size ),
        };

        // Copy data to message
        memcpy( &msg.data, p_data, size );

        // Transmit
        if ( eCAN_OK != can_transmit( eCAN_SYSTEM, &msg ))
        {
            status = eBOOT_ERROR;
        }

    #endif // ( 0 == BOOT_IF_CAN_COM_EN )

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Receive data over Bootloader communication port
*
* @note In case of reception error or RX FIFO empty function shall return "eBOOT_ERROR" code!
*
* @param[in]    p_data  - Data to transmit
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_receive(uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    #if ( 0 == BOOT_IF_CAN_COM_EN )
        #ifdef DEBUG
            if ( eUART_OK != uart_receive( eUART_BOOT, p_data ))
            {
                status = eBOOT_ERROR;
            }
        #else
            if ( eUART_OK != uart_receive( eUART_DBG, p_data ))
            {
                status = eBOOT_ERROR;
            }
        #endif
    #else

        can_msg_t msg = {0};

        // Take all received CAN message and make binary stream out of it
        while( eCAN_OK == can_receive( eCAN_SYSTEM, &msg ))
        {
            // Filter CAN messages
            if ( BOOT_IF_CAN_MSG_RX_ID == msg.id )
            {
                // Get size of received data
                const uint8_t rx_bytes = can_dlc_real_to_raw( msg.dlc );

                // Assemble binary stream
                for ( uint8_t byte = 0; byte < rx_bytes; byte++ )
                {
                    (void) ring_buffer_add( gp_rx_buf, (uint8_t*) &msg.data[byte] );
                }
            }
        }

        // Get data from RX FIFO
        if ( eRING_BUFFER_OK != ring_buffer_get( gp_rx_buf, (uint8_t*) p_data ))
        {
            status = eBOOT_ERROR;
        }

    #endif // ( 0 == BOOT_IF_CAN_COM_EN )

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Clear Bootloader interface reception FIFO
*
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_clear_rx_buf(void)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    #if ( 0 == BOOT_IF_CAN_COM_EN )
        #ifdef DEBUG
            if ( eUART_OK != uart_clear_rx_buf( eUART_BOOT ))
            {
                status = eBOOT_ERROR;
            }
        #else
            if ( eUART_OK != uart_clear_rx_buf( eUART_DBG ))
            {
                status = eBOOT_ERROR;
            }
        #endif
    #else

        if ( eCAN_OK != can_clear_rx_buf( eCAN_SYSTEM ))
        {
            status = eBOOT_ERROR;
        }

    #endif // ( 0 == BOOT_IF_CAN_COM_EN )

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Write data to internal MCU flash
*
*   @note In case of write error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @param[in]    p_data  - Data to write
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_write(const uint32_t addr, const uint32_t size, const uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_write( addr, size, p_data ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Read data from internal MCU flash
*
*   @note In case of read error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @param[out]    p_data  - Data to write
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_read(const uint32_t addr, const uint32_t size, uint8_t * const p_data)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_read( addr, size, p_data ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

////////////////////////////////////////////////////////////////////////////////
/**
*       Erase data in internal MCU flash
*
*   @note In case of write error function shall return "eBOOT_ERROR" code!
*
* @param[in]    addr    - Address of flash to write to
* @param[in]    size    - Size of data to write in bytes
* @return       status  - Status of operation
*/
////////////////////////////////////////////////////////////////////////////////
boot_status_t boot_if_flash_erase(const uint32_t addr, const uint32_t size)
{
    boot_status_t status = eBOOT_OK;

    // USER CODE BEGIN...

    if ( eFLASH_OK != flash_erase( addr, size ))
    {
        status = eBOOT_ERROR;
    }

    // USER CODE END...

    return status;
}

#if ( 1 == BOOT_CFG_CRYPTION_EN )

    ////////////////////////////////////////////////////////////////////////////////
    /**
    *       Decrypt flash data received over communication
    *
    * @param[in]    p_crypt_data    - Pointer to crypted flash data
    * @param[out]   p_decrypt_data  - Pointer to decrypted flash data
    * @param[in]    size            - Size of data to decrypt
    * @return       void
    */
    ////////////////////////////////////////////////////////////////////////////////
    void boot_if_decrypt_data(const uint8_t * const p_crypt_data, uint8_t * const p_decrypt_data, const uint32_t size)
    {
        // USER CODE BEGIN...

        (void) cmox_cipher_append( gp_cipher_ctx, p_crypt_data, size, p_decrypt_data, NULL );

        // USER CODE END...
    }

    ////////////////////////////////////////////////////////////////////////////////
    /**
    *       Reset cryto engine
    *
    * @return       void
    */
    ////////////////////////////////////////////////////////////////////////////////
    void boot_if_decrypt_reset(void)
    {
        // USER CODE BEGIN...

        //Cleanup the handle
        (void) cmox_cipher_cleanup( gp_cipher_ctx );

        // USER CODE END...
    }

#endif

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////
